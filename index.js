var esprima = require('esprima');
var escodegen = require('escodegen');
var path = require('path');
var fs = require('fs');
var glob = require("glob");
var mkdirp = require("mkdirp");
var os = require("os");

var tools = require('./lib/tools.js');

var genOptions = {
    format: {
        newline: os.EOL,
        quotes: 'single'
    },
    comment: true
};


exports.build = build;
exports.compile = compile;
exports.generateDepFile = generateDepFile;

function resolveFiles(files, defaultFile) {
    files = files || defaultFile || '**/*.js';

    if (!(Array.isArray(files) )) {
        files = [files];
    }

    return files.reduce(function(prev, pattern) {
        var matches = glob.sync(pattern).
            filter(function(filename) {
                return /\.js$/.test(filename);
            });
        return prev.concat(matches)

    }, []);
}

/**
 * Compile a File
 * @param {Object} options
 * @param {String} options.srcFile file to compile
 * @param {Object} options.package config for package
 * @return {Object}
 */
function compileFile(options) {

    var srcFile = options.srcFile;
    var srcCnt = fs.readFileSync(srcFile, 'utf8');

    var ret = {
        srcCode: srcCnt
    };

    var ast = esprima.parse(srcCnt, {
        comment: true,
        tokens: true,
        range: true
    });

    var kissyAddFunctions = tools.getKISSYAddFunctions(ast);

    if (!kissyAddFunctions.length) {
        ret.isKISSY = false;
    } else {
        kissyAddFunctions.forEach(function(fnAdd){
            tools.fixModuleName(fnAdd, srcFile, options.package);
        });

        ret.isKISSY = true;

        ret.modules = kissyAddFunctions.map(tools.getKissyModuleInfo);
        escodegen.attachComments(ast, ast.comments, ast.tokens);

        ret.genCode = escodegen.generate(ast, genOptions);


    }

    return ret;
}


/**
 * Compile a KISSY Package
 * @param {Object} pkg
 * @param {String} pkg.name Name of Package
 * @param {String} pkg.path Package path in filesystem
 * @param {Array} files optional files to analytic
 * @return {Object} The compile result of package
 */
function compile(pkg, files) {

    var ret = {};

    var pkgPath = pkg.path;
    var ignoredFiles = [];

    files = resolveFiles(files, path.join(pkgPath, '**/*'));

    ret.files = files.
        map(function(file){
            return path.relative(pkgPath, file);
        }).
        filter(function(filename){
            var isPkgFile = !(/^\.\./).test(filename);
            if (!isPkgFile) {
                ignoredFiles.push({
                    srcFile: path.join(pkgPath, filename)
                });
            }
            return isPkgFile;
        }).
        map(function(filename){
            var srcFile = path.join(pkgPath, filename);

            try {
                var mo =  compileFile({
                    'srcFile': srcFile,
                    'package': pkg
                });
            } catch(e) {
                e.path = srcFile;
                e.filename = filename;
                throw(e);
            }


            mo.filename = filename;
            mo.srcFile = srcFile;

            return mo;
        });


    ret.ignoredFiles = ignoredFiles;
    var modules = {};

    ret.files.
        map(function(result){
            return result.modules;
        }).
        reduce(function(prev, current) {
            return prev.concat(current);
        }, []).
        filter(function (m) {
            return m && m.requires && m.requires.length;
        }).
        forEach(function(m) {
            modules[m.name] = {
                requires: m.requires
            }
        });

    ret.modules = modules;

    return ret;
}

/**
 * Generate dep map file from modules;
 */
function  generateDepFile(modules) {

    var codeBase = "KISSY.config('modules');";
    var modulesAst = esprima.parse(codeBase);
    modulesAst.body[0].expression.arguments.push(tools.toAst(modules));

    return "/** Generated by KPC **/" + os.EOL +
        escodegen.generate(modulesAst, genOptions)  + os.EOL;
}


/**
 * Build a KISSY Package
 * @param {Object} options
 * @param {Object} options.pkg Config Package
 * @param {String} options.dest Package path in filesystem
 * @param {String} options.depFile filename for dep file
 * @param {Array|String}  files Files to compile
 * @return {Object} the package compiled
 */
function build(options, files) {

    var dest = options.dest;

    if (!dest) {
        throw new Error('No dest in options');
    }

    files = resolveFiles(files);

    var pkgData = compile(options.pkg, files);


    pkgData.files.forEach(function(file) {
        var destFile = path.join(dest, file.filename);

        var code = file.genCode || file.srcCode || null;

        mkdirp.sync(path.dirname(destFile));

        if (code) {
            fs.writeFileSync(destFile, code);
        } else {
            fs.writeFileSync(destFile, fs.readFileSync(file.srcFile));
        }
    });


    if (pkgData.modules && options.depFile) {
        var depFileCnt = generateDepFile(pkgData.modules);
        mkdirp.sync(path.dirname(options.depFile));
        fs.writeFileSync(options.depFile, depFileCnt);
    }

    return pkgData;
}