var esprima = require('esprima');
var escodegen = require('escodegen');
var path = require('path');
var fs = require('fs');
var glob = require("glob");
var mkdirp = require("mkdirp");
var os = require("os");
var _ = require('lodash');

var tools = require('./lib/tools.js');

var genOptions = {
    format: {
        newline: os.EOL,
        quotes: 'single'
    },
    comment: true
};


exports.buildPackage = buildPackage;
exports.compilePackage = compilePackage;
exports.generateDepFile = generateDepFile;


/**
 * Compile a File
 * @param {Object} options
 * @param {String} options.srcFile file to compile
 * @param {Object} options.package config for package
 * @return {Object}
 */
function compileFile(options) {

    var srcFile = options.srcFile;
    var srcCnt = fs.readFileSync(srcFile, 'utf8');

    var ret = {
        srcCode: srcCnt
    };

    var ast = esprima.parse(srcCnt);

    var kissyAddFunctions = tools.getKISSYAddFunctions(ast);

    if (!kissyAddFunctions.length) {
        ret.isKISSY = false;
    } else {
        kissyAddFunctions.forEach(function(fnAdd){
            tools.fixModuleName(fnAdd, srcFile, options.package);
        });
        ret.isKISSY = true;
//        console.log(JSON.stringify(ast, null, 4));
        ret.genCode = escodegen.generate(ast, genOptions);
        ret.modules = kissyAddFunctions.map(tools.getKissyModuleInfo);
    }

    return ret;
}


/**
 * Compile a KISSY Package
 * @param {Object} pkg
 * @param {String} pkg.name Name of Package
 * @param {String} pkg.path Package path in filesystem
 * @param {String} pkg.charset Charset for package
 * @param {Array} files files to analytic
 * @return {Object} The compile result of package
 */
function compilePackage(pkg, files) {

    var ret = {
        modules: {}
    };

    var pkgPath = pkg.path;
    var ignoredFiles = [];

    ret.files = files.
        map(function(filename){
            return path.relative(pkgPath, filename);
        }).
        filter(function(filename){
            var isPkgFile = !(/^\.\./).test(filename);
            if (!isPkgFile) {
                ignoredFiles.push({
                    srcFile: path.join(pkgPath, filename)
                });
            }
            return isPkgFile;
        }).
        map(function(filename){
            var srcFile = path.join(pkgPath, filename);

            try {
                var mo =  compileFile({
                    'srcFile': srcFile,
                    'package': pkg
                });
            } catch(e) {
                e.path = srcFile;
                e.filename = filename;
                throw(e);
            }


            mo.filename = filename;
            mo.srcFile = srcFile;
            mo.type = 'js';

            return mo;
        });


    ret.ignoredFiles = ignoredFiles;
    var modules = {};

    ret.files.
        map(function(result){
            return result.modules;
        }).
        reduce(function(prev, current) {
            return prev.concat(current);
        }, []).
        filter(function (m) {
            return m && m.requires && m.requires.length;
        }).
        forEach(function(m) {
            modules[m.name] = {
                requires: m.requires
            }
        });

    ret.modules = modules;

    return ret;
}

/**
 * Generate dep map file from modules;
 */
function  generateDepFile(modules) {

    var codeBase = "KISSY.config('modules');";
    var modulesAst = esprima.parse(codeBase);
    modulesAst.body[0].expression.arguments.push(tools.toAst(modules));

    var code =  "/** Generated by KPC **/" + os.EOL +
        escodegen.generate(modulesAst, genOptions)  + os.EOL;

    return code;
}


/**
 * Build a KISSY Package
 * @param {Object} options
 * @param {Object} options.pkg Config Package
 * @param {String} options.dest Package path in filesystem
 * @param {String} options.depFilename filename for dep file
 * @param {String} options.charset charset for output file
 * @param {Array|String}  files Files to compile
 */
function buildPackage(options, files) {

    var dest = options.dest;

    if (!dest) {
        throw new Error('No dest in options');
    }

    options.depFilename = options.depFilename || 'deps.js';

    if (!files) {
        files = '**/*.js'
    }

    if (!(Array.isArray(files) )) {
        files = [files];
    }

    var buildPath = options.pkg.path;

    var files = files.reduce(function(prev, pattern) {
            return prev.concat(
                glob.sync(pattern, {
                    cwd: buildPath
                }).filter(function(filename){
                    return /\.js$/.test(filename);
                })).map(function(filename){
                    return path.join(buildPath, filename)
                })
        }, []);

    var pkgData = compilePackage(options.pkg, files);


    pkgData.files.forEach(function(file) {
        var destFile = path.join(dest, file.filename);

        var code = file.genCode || file.srcCode || null;

        mkdirp.sync(path.dirname(destFile));

        if (code) {
            fs.writeFileSync(destFile, code);
        } else {
            fs.writeFileSync(destFile, fs.readFileSync(file.srcFile));
        }
    });


    if (pkgData.modules) {
        var depFile = generateDepFile(pkgData.modules);
        var destDepFile = path.join(dest, options.depFilename);
        mkdirp.sync(path.dirname(destDepFile));
        fs.writeFileSync(destDepFile, depFile);
    }
}